<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Einblick in Javas Stream Gatherers | Hendrik Schick - Software Freelancer/Contractor</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Einblick in Javas Stream Gatherers" />
<meta name="author" content="Hendrik Schick" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Neues finalisiertes Feature in Java 24" />
<meta property="og:description" content="Neues finalisiertes Feature in Java 24" />
<link rel="canonical" href="http://localhost:4000/blog/stream-gatherers" />
<meta property="og:url" content="http://localhost:4000/blog/stream-gatherers" />
<meta property="og:site_name" content="Hendrik Schick - Software Freelancer/Contractor" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-04-15T18:50:42+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Einblick in Javas Stream Gatherers" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Hendrik Schick"},"dateModified":"2025-04-15T18:50:42+02:00","datePublished":"2025-04-15T18:50:42+02:00","description":"Neues finalisiertes Feature in Java 24","headline":"Einblick in Javas Stream Gatherers","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/stream-gatherers"},"url":"http://localhost:4000/blog/stream-gatherers"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css">
  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Hendrik Schick - Software Freelancer/Contractor" />
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Hendrik Schick - Software Freelancer/Contractor</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/freelance-offer">Freelance-service/Contractor Softwareengineer</a><a class="page-link" href="/impressum/">Impressum</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Einblick in Javas Stream Gatherers</h1>
    <div class="post-meta">
      <time class="dt-published" datetime="2025-04-15T18:50:42+02:00" itemprop="datePublished">
        Apr 15, 2025
      </time>
    </div>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="neues-finalisiertes-feature-in-java-24">Neues <em>finalisiertes</em> Feature in Java 24</h2>

<p>Bereits in Java 22 und Java 23 sind die Stream-Gatherers enthalten, allerdings noch als Preview.
In der neuesten <strong>Java Version 24</strong>, die am 18.03.2025, während der gleichzeitig stattfindenden JavaOne 2025, 
released wurde, sind Stream Gatherers nun als finalisiertes Feature enthalten.</p>

<p>Stream Gatherers kamen finalisiert mit <a href="https://openjdk.org/jeps/485">JEP 485</a> in Java 24. 
Es gab keine Änderungen bei dem Stream Gatherers zum Preview in Java 23.</p>

<p>Stream Gatherers sind eine <strong>neue intermediate Stream-Operation</strong>. Intermediate, da die Methode <code class="language-plaintext highlighter-rouge">gather(Gatherer&lt;? super T, ?, R&gt; gatherer)</code>
selbst wieder ein <code class="language-plaintext highlighter-rouge">Stream&lt;R&gt;</code> zurückgibt. Der Typ-Parameter <code class="language-plaintext highlighter-rouge">R</code> wird für diese Methode speziell gesetzt, daher kann der <code class="language-plaintext highlighter-rouge">Gatherer</code>
auch den Typen der Streams verändern.</p>

<h2 id="warum-braucht-es-diese-neue-stream-operation-auf-dem-stream-interface">Warum braucht es diese neue Stream-Operation auf dem Stream-Interface?</h2>

<p>Das Problem aller vorher bestehenden intermediate Stream-Operationen ist, dass diese keinen eigens-definierbaren State innerhalb der Stream-Operation haben.
Es gibt bereits ìntermediate Stream Operationen, die einen internen State haben, beispielsweise <code class="language-plaintext highlighter-rouge">distinct</code>. Hierbei werden duplikate Elemente anhand der 
<code class="language-plaintext highlighter-rouge">Object#equals(Object)</code>-Methode herausgefiltert. Allerdings ist hier ganz genau vorgegeben welcher State gespeichert wird und <code class="language-plaintext highlighter-rouge">distinct</code> ist nur sehr limitiert einsetzbar.</p>

<p>Für die zweite Art von Stream-Operationen, den terminal Operationen, gibt es bereits die generisch einsetzbare <code class="language-plaintext highlighter-rouge">collect(Collector&lt;? super T, A, R&gt; collector)</code> Methode,
welche einen <code class="language-plaintext highlighter-rouge">Collector</code>-Objekt als Parameter erwartet. Beispielsweise mithilfe der accumulator-Funktion eines Collectors kann ein State berücksichtigt werden.
Der Accumulator ist wie folgt auf dem Collector-Interface definiert <code class="language-plaintext highlighter-rouge">BiConsumer&lt;A, T&gt; accumulator()</code> und muss da es eine abstrakte Methode ist, zwingend implementiert werden.
Innerhalb der Implementierung des Accumulator werden den groups (Parameter 1) jeweils ein neues Element entweder hinzugefügt oder nicht. Der accumulator wird für jedes Element aufgerufen
und hierbei kann anhand der bereits zu den groups hinzugefügten Elementen entschieden werden, ob ein weiteres hinzugefügt wird oder nicht.</p>

<h2 id="beispiel-eines-selbsterstellen-stream-gatherers">Beispiel eines selbsterstellen Stream Gatherers</h2>

<p>Stream Gatherers können granular selbst erstellt werden mittels Implementierung des neuen <code class="language-plaintext highlighter-rouge">java.util.stream.Gatherer</code>-Interfaces.
Interessanterweise ist dieses Interface ein funktionales Interface, obwohl die <code class="language-plaintext highlighter-rouge">@FunctionalInterface</code> Annotation nicht gesetzt wurde.</p>

<p>Ein Gatherer besteht im Kern aus 4 Bestandteilen. Diese sind ein Initializer, ein Integrator, ein Combiner und ein Finisher.</p>
<ul>
  <li>Initializer: <code class="language-plaintext highlighter-rouge">Supplier&lt;A&gt; initializer()</code>, welcher den initialen Zustand erzeugen kann. Im Default wird kein initialer Zustand erzeugt und <code class="language-plaintext highlighter-rouge">null</code> zurückgegeben.</li>
  <li>Integrator: <code class="language-plaintext highlighter-rouge">Integrator&lt;A, T, R&gt; integrator()</code>
    <ul>
      <li>einzig abstrakte Methode auf dem <code class="language-plaintext highlighter-rouge">Gatherer</code>-Interface</li>
      <li><code class="language-plaintext highlighter-rouge">Integrator</code> selbst ist auch ein funktionales Interface</li>
      <li><code class="language-plaintext highlighter-rouge">boolean integrate(A state, T element, Downstream&lt;? super R&gt; downstream)</code> muss implementiert werden</li>
    </ul>
  </li>
  <li>Combiner: <code class="language-plaintext highlighter-rouge">BinaryOperator&lt;A&gt; combiner()</code>
    <ul>
      <li>nimmt zwei zwischenzeitliche Streams und fasst sie in einen zusammen</li>
      <li>muss implementiert sein für parallel ausgeführte gatherer-Stream operationen</li>
      <li>im default wird eine <code class="language-plaintext highlighter-rouge">UnsupportedOperation</code>-Exception geworfen, daher kann hier der Gatherer nur sequentiell durchlaufen werden</li>
    </ul>
  </li>
  <li>Finisher: <code class="language-plaintext highlighter-rouge">BiConsumer&lt;A, Downstream&lt;? super R&gt;&gt; finisher()</code>
    <ul>
      <li>finale Aktion am Ende der Stream-operation.</li>
      <li>im default ein no-op</li>
    </ul>
  </li>
</ul>

<p>Auf dem Gatherer-Interface gibt es mehrere ofSequential- (zwingend sequentiell) und of (parallelisierbar)-Factory Methoden, um Gatherer-Objekte zu erstellen.<br />
Sehr simpel ist beispielsweise ofSequential auf dem Gatherer-Interface</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="nc">Gatherer</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="nc">Void</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="nf">ofSequential</span><span class="o">(</span>
          <span class="nc">Integrator</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">,</span> <span class="no">T</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="n">integrator</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nf">of</span><span class="o">(</span>
              <span class="n">defaultInitializer</span><span class="o">(),</span>
              <span class="n">integrator</span><span class="o">,</span>
              <span class="n">defaultCombiner</span><span class="o">(),</span>
              <span class="n">defaultFinisher</span><span class="o">()</span>
      <span class="o">);</span>
  <span class="o">}</span>
</code></pre></div></div>
<p>Es wird ein Gatherer zurückgegeben, der sequentiell und stateless ist und allein durch den <code class="language-plaintext highlighter-rouge">integrator</code> an die jeweiligen Bedürfnisse angepasst wird.</p>

<h2 id="vordefinierte-stream-gatherers-im-jdk">Vordefinierte Stream Gatherers im JDK</h2>

<p>Die <code class="language-plaintext highlighter-rouge">final</code> und nicht-initiierbare Klasse <code class="language-plaintext highlighter-rouge">java.util.Stream.Gatherers</code> beinhaltet fünf vordefinierte Gatherers.<br />
Diese sind die folgenden:</p>
<ul>
  <li><strong>fold</strong>
    <ul>
      <li>führt eine geordnete, reduction-like Transformation durch.</li>
      <li>stateful many-to-one gatherer</li>
      <li>erwartet 2 Argumente: <code class="language-plaintext highlighter-rouge">Supplier</code> für den initialen Wert, <code class="language-plaintext highlighter-rouge">BiFunction</code> als folding operation,
        <ul>
          <li>wobei bei der <code class="language-plaintext highlighter-rouge">BiFunction</code> der erste Parameter das derzeitig bestehende Endresultat ist und</li>
          <li>der zweite Parameter das jeweilige Element darstellt.</li>
        </ul>
      </li>
      <li>nützlich um ein Endresultat zu ermitteln basierend auf mehreren Elementen des Streams</li>
    </ul>
  </li>
  <li><strong>scan</strong>
    <ul>
      <li>führt eine geordnete Transformation durch, wobei für jedes Element ein neues Element in den resultierenden Stream kommt</li>
      <li>wie bei <code class="language-plaintext highlighter-rouge">fold</code> erwartet <code class="language-plaintext highlighter-rouge">scan</code> 2 Argumente: <code class="language-plaintext highlighter-rouge">Supplier</code> für den initialen Wert und eine <code class="language-plaintext highlighter-rouge">BiFunction</code>
        <ul>
          <li>das erste Argument der <code class="language-plaintext highlighter-rouge">BiFunction</code> ist der derzeitige <em>state</em>, der in jeder Iteration verändert werden kann</li>
          <li>das zweite Argument ist ein Element des Streams, d.h. die BiFunction wird für jedes Element des Streams aufgerufen.</li>
        </ul>
      </li>
      <li>anders als bei fold wird nicht ein Stream mit einem singulären Element zurückgegeben, sondern die Anzahl der Elemente des Streams ändern sich <em>nicht</em></li>
      <li>stateful one-to-one gatherer</li>
    </ul>
  </li>
  <li><strong>mapConcurrent</strong>
    <ul>
      <li>führt mitgegebene <code class="language-plaintext highlighter-rouge">Function</code> (Parameter 2) nebenläufig aus mithilfe von virtual threads</li>
      <li>Anzahl der virtual threads wird als <code class="language-plaintext highlighter-rouge">int</code> mit Parameter 1 festgelegt</li>
      <li>one-to-one gatherer, <strong>ohne state innerhalb des Gatherers</strong></li>
    </ul>
  </li>
  <li><strong>windowFixed</strong>
    <ul>
      <li>es gibt 2 window methoden in der Gatherer Klasse</li>
      <li>die erste ist <code class="language-plaintext highlighter-rouge">windowFixed</code></li>
      <li>diese erwartet nur 1 Parameter. Ein int, der die window-size angibt.</li>
      <li>die Elemente des Streams werden dann in Listen aufgeteilt entsprechend der window-size</li>
      <li>Jedes Element ist auch in den Sub-Listen nur insgesamt ein mal vorhanden</li>
      <li>Beispielsweise:
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">windows</span> <span class="o">=</span>
       <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">).</span><span class="na">gather</span><span class="o">(</span><span class="nc">Gatherers</span><span class="o">.</span><span class="na">windowFixed</span><span class="o">(</span><span class="mi">3</span><span class="o">)).</span><span class="na">toList</span><span class="o">();</span>
<span class="c1">// will contain: [[1, 2, 3], [4, 5, 6], [7, 8]]</span>
</code></pre></div>        </div>
      </li>
      <li>many-to-many gatherer, stateful um derzeitige Anzahl Elemente je Liste <em>mitzuzählen</em></li>
    </ul>
  </li>
  <li><strong>windowSliding</strong>
    <ul>
      <li>die zweite window methode in der Gatherer Klasse</li>
      <li>auch hier wird nur 1 Parameter erwartet, welcher wieder die windowSize angibt</li>
      <li>hier werden die <em>windows</em> jeweils auch mit den Elementen des vorherigen <em>windows</em> (Liste) erstellt, nur das <em>älteste</em> Element fällt jeweils raus</li>
      <li>Beispielsweise:
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">windows6</span> <span class="o">=</span>
       <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">).</span><span class="na">gather</span><span class="o">(</span><span class="nc">Gatherers</span><span class="o">.</span><span class="na">windowSliding</span><span class="o">(</span><span class="mi">6</span><span class="o">)).</span><span class="na">toList</span><span class="o">();</span>
 <span class="c1">// will contain: [[1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6, 7], [3, 4, 5, 6, 7, 8]]</span>
</code></pre></div>        </div>
      </li>
      <li>many-to-many gatherer, stateful um derzeitige Anzahl Elemente je Liste <em>mitzuzählen</em></li>
      <li>beide window-Gatherer erstellen jeweils unmodifiable Listen</li>
    </ul>
  </li>
</ul>

<h2 id="fazit--meine-meinung"><em>Fazit &amp; Meine Meinung</em></h2>

<p>Es ist die erste neue Stream-Operation seit der Einführung von der intermediate operation <code class="language-plaintext highlighter-rouge">mapMulti</code> und der terminal operation <code class="language-plaintext highlighter-rouge">toList</code> in Java 16.
Daher ist es eine durchaus bedeutende Änderung, insbesondere da das <strong>Stream-Interface</strong> eines der meistgenutzten modernen Java-Features ist.
Neue Features werden zu Java eher spärlich und nach intensiver Abwägung hinzugefügt. Mittels des generischen Stream-Gatherers können nun Entwickler selbst diverse 
intermediate Stream-Operationen kreieren.</p>

<p>Auch ich hatte schon mehrmals die Erfahrung gemacht im Job, dass ich eine Stream-Pipeline ohne einen vorhandenen State innerhalb des Streams nicht schreiben konnte.
Vor Java 24 gab es hier mehrere Möglichkeiten. Es konnte der Stream ganz terminiert werden, um die zustandsbehaftete Operation dann ausserhalb der Stream-API durchzuführen.
Andere Optionen sind die schon existierende zustandsbehaftete Stream-Operation <code class="language-plaintext highlighter-rouge">distinct</code>, wobei dazu teilweise die <code class="language-plaintext highlighter-rouge">equals</code> und <code class="language-plaintext highlighter-rouge">hashCode</code> Methoden des jeweiligen Elemententypes
entsprechend den Anforderungen unschön angepasst werden muss. Eine weitere Option, die ich auch bereits verwendet hatte, ist einen Collector dafür zu nutzen.
Mittels <code class="language-plaintext highlighter-rouge">Collector.of()</code> kann anhand des <code class="language-plaintext highlighter-rouge">BiConsumer</code>-Accumulators entschieden werden ob Elemente des Streams in die neu erstellte Kollektion kommen anhand der schon vorhandenen Elemente im neuen Stream.
Hier kann also anhand des States (bereits hinzugefügte Elemente) eine Entscheidung getroffen werden.</p>

<p>Diese Optionen sind aber alle keine sauberen Lösungen und sind eher Hacks. Es fehlte eine generische intermediate Stream-Operation, die auch zustandsbehaftet sein kann.
Mit den neuen Stream-Gatherers ist dies möglich. So kann noch mehr imperativer Code im funktionalen, deklarativen Stil innerhalb Streams geschrieben werden.</p>

<p><em>Hinweis: Dieser Blogbeitrag wurde ohne Nutzung von KI geschrieben.</em></p>

  </div><a class="u-url" href="/blog/stream-gatherers" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="http://localhost:4000/feed.xml">
            <svg class="svg-icon orange">
              <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
                11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
                13.806c0-1.21.983-2.195 2.194-2.195zM10.606
                16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
              />
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Hendrik Schick</li>
          <li><a class="u-email" href="mailto:mail@hendrik-schick.me">mail@hendrik-schick.me</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Ich schreibe über Softwareentwicklung und weitere Themen, die mir über den Weg laufen.  Ich biete Softwareentwicklung und Beratung zur Softwareentwicklung als Freelancer an. Schreibe mir gerne eine E-Mail,  wenn du mit mir in Kontakt treten möchtest.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
    <a rel="me" href="https://github.com/ky0n" target="_blank" title="GitHub">
      <span class="grey fa-brands fa-github fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="https://www.linkedin.com/in/hendrik-schick/" target="_blank" title="LinkedIn">
      <span class="grey fa-brands fa-linkedin fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="https://bsky.app/profile/hendrik-schick.me" target="_blank" title="BlueSky">
      <span class="grey fa-brands fa-bluesky fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="https://www.meetup.com/members/382573529/" target="_blank" title="meetup">
      <span class="grey fa-brands fa-meetup fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="https://t.me/hendrikk" target="_blank" title="telegram">
      <span class="grey fa-brands fa-telegram fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="https://steamcommunity.com/profiles/76561198370862368/" target="_blank" title="steam">
      <span class="grey fa-brands fa-steam fa-lg"></span>
    </a>
  </li></ul>
</div>

  </div>

</footer>

</body>

</html>
